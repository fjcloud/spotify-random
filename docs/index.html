<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Random Track Selector</title>
    <style>
        :root {
            --spotify-green: #1DB954;
            --spotify-black: #191414;
            --spotify-dark: #121212;
            --spotify-gray: #535353;
            --spotify-light: #B3B3B3;
        }
        
        body {
            font-family: 'Circular', 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            background-color: var(--spotify-black);
            color: white;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        
        header {
            background-color: var(--spotify-dark);
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        h1 {
            margin: 0;
            font-size: 2.2rem;
            color: var(--spotify-green);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        
        .selection-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .selection-area {
                grid-template-columns: 1fr;
            }
        }
        
        .selection-box {
            background-color: var(--spotify-dark);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .selection-box h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--spotify-green);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .decade-buttons, .language-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .btn {
            background-color: var(--spotify-gray);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            min-width: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .btn:hover {
            transform: scale(1.05);
            background-color: #636363;
        }
        
        .btn.selected {
            background-color: var(--spotify-green);
            font-weight: bold;
        }
        
        .action-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            gap: 20px;
        }
        
        .play-btn {
            background-color: var(--spotify-green);
            font-size: 18px;
            font-weight: bold;
            padding: 15px 40px;
            min-width: 200px;
        }
        
        .play-btn:hover {
            background-color: #1ed760;
        }
        
        .select-all-btn {
            background-color: transparent;
            border: 1px solid var(--spotify-light);
            color: var(--spotify-light);
        }
        
        .select-all-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }
        
        .loader {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 5px solid var(--spotify-green);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #message {
            text-align: center;
            margin: 15px 0;
            min-height: 20px;
            color: var(--spotify-light);
        }
        
        footer {
            background-color: var(--spotify-dark);
            text-align: center;
            padding: 15px;
            color: var(--spotify-light);
            font-size: 14px;
            margin-top: auto;
        }
        
        .badge {
            font-size: 12px;
            background-color: var(--spotify-gray);
            border-radius: 12px;
            padding: 2px 6px;
            margin-left: 5px;
            color: white;
        }
        
        /* Selection summary */
        .selection-summary {
            background-color: var(--spotify-dark);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            color: var(--spotify-light);
        }
        
        .current-selections {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .selection-tag {
            background-color: var(--spotify-gray);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
        }

        /* Database setup area */
        .db-setup-area {
            background-color: var(--spotify-dark);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .progress-bar-container {
            width: 100%;
            background-color: var(--spotify-gray);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 20px;
            background-color: var(--spotify-green);
            width: 0%;
            border-radius: 10px;
            transition: width 0.3s;
        }
        
        .progress-text {
            margin-top: 10px;
            font-size: 14px;
            color: var(--spotify-light);
        }
        
        .app-container {
            display: none;
        }
        
        /* Debug panel */
        .debug-panel {
            margin-top: 20px;
            background-color: #333;
            border-radius: 8px;
            padding: 15px;
            font-family: monospace;
            display: none;
        }
        
        .debug-panel h3 {
            margin-top: 0;
            color: var(--spotify-green);
        }
        
        .debug-panel pre {
            white-space: pre-wrap;
            word-break: break-all;
            color: #ddd;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <header>
        <h1>üéµ Random Spotify Track Selector</h1>
    </header>
    
    <div class="container">
        <!-- Database Setup Area - Shown First -->
        <div class="db-setup-area" id="db-setup">
            <h2>Database Setup</h2>
            <p>To use this app, you need to download the track database.</p>
            <p>This is a one-time download of approximately 40 MB compressed (137 MB uncompressed).</p>
            <p>The database will be cached in your browser for future use.</p>
            
            <button class="btn play-btn" id="download-db-btn">Download Database</button>
            
            <div class="progress-bar-container" id="progress-container" style="display: none;">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="progress-text" id="progress-text"></div>
        </div>
        
        <!-- Main App Area - Hidden until DB is loaded -->
        <div class="app-container" id="app-container">
            <div class="selection-area">
                <div class="selection-box">
                    <h2>üï∞Ô∏è Decades</h2>
                    <div class="decade-buttons">
                        <button class="btn select-all-btn" id="select-all-decades">All Decades</button>
                        <button class="btn decade-btn" data-decade="1950">1950s</button>
                        <button class="btn decade-btn" data-decade="1960">1960s</button>
                        <button class="btn decade-btn" data-decade="1970">1970s</button>
                        <button class="btn decade-btn" data-decade="1980">1980s</button>
                        <button class="btn decade-btn" data-decade="1990">1990s</button>
                        <button class="btn decade-btn" data-decade="2000">2000s</button>
                        <button class="btn decade-btn" data-decade="2010">2010s</button>
                        <button class="btn decade-btn" data-decade="2020">2020s</button>
                    </div>
                </div>
                
                <div class="selection-box">
                    <h2>üåê Languages</h2>
                    <div class="language-buttons">
                        <button class="btn select-all-btn" id="select-all-languages">All Languages</button>
                        <button class="btn lang-btn" data-lang="en">üá¨üáß English</button>
                        <button class="btn lang-btn" data-lang="es">üá™üá∏ Spanish</button>
                        <button class="btn lang-btn" data-lang="fr">üá´üá∑ French</button>
                        <button class="btn lang-btn" data-lang="de">üá©üá™ German</button>
                        <button class="btn lang-btn" data-lang="it">üáÆüáπ Italian</button>
                        <button class="btn lang-btn" data-lang="pt">üáµüáπ Portuguese</button>
                        <button class="btn lang-btn" data-lang="ja">üáØüáµ Japanese</button>
                        <button class="btn lang-btn" data-lang="ko">üá∞üá∑ Korean</button>
                        <button class="btn lang-btn" data-lang="zh">üá®üá≥ Chinese</button>
                        <button class="btn lang-btn" data-lang="hi">üáÆüá≥ Hindi</button>
                        <button class="btn lang-btn" data-lang="ar">üá∏üá¶ Arabic</button>
                        <button class="btn lang-btn" data-lang="ru">üá∑üá∫ Russian</button>
                        <button class="btn lang-btn" data-lang="sv">üá∏üá™ Swedish</button>
                        <button class="btn lang-btn" data-lang="nl">üá≥üá± Dutch</button>
                        <button class="btn lang-btn" data-lang="pl">üáµüá± Polish</button>
                        <button class="btn lang-btn" data-lang="tr">üáπüá∑ Turkish</button>
                        <button class="btn lang-btn" data-lang="th">üáπüá≠ Thai</button>
                        <button class="btn lang-btn" data-lang="id">üáÆüá© Indonesian</button>
                        <button class="btn lang-btn" data-lang="tl">üáµüá≠ Tagalog</button>
                        <button class="btn lang-btn" data-lang="zxx">üéπ Instrumental</button>
                        <button class="btn lang-btn" data-lang="unknown">‚ùì Unknown</button>
                    </div>
                </div>
            </div>
            
            <div class="selection-summary">
                <div>Your current selection:</div>
                <div class="current-selections" id="selection-display">
                    <div class="selection-tag">No selection yet</div>
                </div>
            </div>
            
            <div class="action-area">
                <button class="btn play-btn" id="find-track-btn">Find Random Track</button>
                <div class="loader" id="loader"></div>
                <div id="message"></div>
            </div>
            
            <div class="debug-panel" id="debug-panel">
                <h3>Debug Information</h3>
                <pre id="debug-output"></pre>
            </div>
        </div>
    </div>
    
    <footer>
        <div id="footer-text">Select at least one decade and language to find a random track</div>
        <div style="margin-top: 10px; font-size: 12px;">
            <a href="#" id="clear-cache" style="color: var(--spotify-light);">Clear cached database</a>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // State to track selected options and available tables
        const state = {
            selectedDecades: [],
            selectedLanguages: [],
            db: null,
            SQL: null,
            availableTables: [],
            isLoading: false,
            debugMode: false,
            dbCached: false
        };
        
        // Constants
        const DB_CACHE_KEY = 'spotify_tracks_db';
        const DB_TIMESTAMP_KEY = 'spotify_tracks_db_timestamp';
        const DB_VERSION_KEY = 'spotify_tracks_db_version';
        const CURRENT_DB_VERSION = '1.0'; // Update this when changing the database structure
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            // Enable debug mode with URL parameter ?debug=true
            const urlParams = new URLSearchParams(window.location.search);
            state.debugMode = urlParams.get('debug') === 'true';
            if (state.debugMode) {
                document.getElementById('debug-panel').style.display = 'block';
            }
            
            // Set up download button
            document.getElementById('download-db-btn').addEventListener('click', downloadAndSetupDB);
            
            // Set up clear cache button
            document.getElementById('clear-cache').addEventListener('click', function(e) {
                e.preventDefault();
                clearCachedDB();
            });
            
            // Check if we already have the database cached
            checkCachedDB();
            
            // Set up event listeners for the main app
            setupAppEventListeners();
        });
        
        // Check if we have a cached database
        async function checkCachedDB() {
            debugLog("Checking for cached database...");
            
            try {
                // Check if IndexedDB is supported
                if (!window.indexedDB) {
                    debugLog("IndexedDB not supported");
                    setProgressText("Your browser doesn't support database caching. Please download the database each time.");
                    return;
                }
                
                // Check if we have a cached version
                const cachedVersion = localStorage.getItem(DB_VERSION_KEY);
                const timestamp = localStorage.getItem(DB_TIMESTAMP_KEY);
                
                if (cachedVersion && cachedVersion === CURRENT_DB_VERSION) {
                    debugLog("Found cached database version:", cachedVersion);
                    setProgressText(`Found cached database from ${new Date(parseInt(timestamp)).toLocaleString()}`);
                    
                    // Load the database from cache
                    const dbArrayBuffer = await getDBFromCache();
                    if (dbArrayBuffer) {
                        await initDatabaseFromArrayBuffer(dbArrayBuffer);
                        showApp();
                        state.dbCached = true;
                        return;
                    }
                } else if (cachedVersion) {
                    debugLog("Cached database is outdated. Version:", cachedVersion);
                    setProgressText("A new version of the database is available. Please download it.");
                } else {
                    debugLog("No cached database found");
                    setProgressText("No cached database found. Please download it.");
                }
            } catch (error) {
                console.error("Error checking cached DB:", error);
                setProgressText("Error checking cached database. Please download again.");
            }
        }
        
        // Get the database from cache
        function getDBFromCache() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("SpotifyTracksDB", 1);
                
                request.onerror = function(event) {
                    console.error("Error opening IndexedDB:", event);
                    reject(new Error("Error opening database cache"));
                };
                
                request.onupgradeneeded = function(event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('database')) {
                        db.createObjectStore('database');
                    }
                };
                
                request.onsuccess = function(event) {
                    const db = event.target.result;
                    const transaction = db.transaction(["database"], "readonly");
                    const objectStore = transaction.objectStore("database");
                    const getRequest = objectStore.get(DB_CACHE_KEY);
                    
                    getRequest.onerror = function(event) {
                        console.error("Error reading from IndexedDB:", event);
                        reject(new Error("Error reading database from cache"));
                    };
                    
                    getRequest.onsuccess = function(event) {
                        if (getRequest.result) {
                            resolve(getRequest.result);
                        } else {
                            resolve(null);
                        }
                    };
                };
            });
        }
        
        // Store the database in cache
        function storeDBInCache(arrayBuffer) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("SpotifyTracksDB", 1);
                
                request.onerror = function(event) {
                    console.error("Error opening IndexedDB:", event);
                    reject(new Error("Error opening database cache"));
                };
                
                request.onupgradeneeded = function(event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('database')) {
                        db.createObjectStore('database');
                    }
                };
                
                request.onsuccess = function(event) {
                    const db = event.target.result;
                    const transaction = db.transaction(["database"], "readwrite");
                    const objectStore = transaction.objectStore("database");
                    const putRequest = objectStore.put(arrayBuffer, DB_CACHE_KEY);
                    
                    putRequest.onerror = function(event) {
                        console.error("Error writing to IndexedDB:", event);
                        reject(new Error("Error caching database"));
                    };
                    
                    putRequest.onsuccess = function(event) {
                        // Save version and timestamp
                        localStorage.setItem(DB_VERSION_KEY, CURRENT_DB_VERSION);
                        localStorage.setItem(DB_TIMESTAMP_KEY, Date.now().toString());
                        resolve();
                    };
                };
            });
        }
        
        // Clear the cached database
        function clearCachedDB() {
            localStorage.removeItem(DB_VERSION_KEY);
            localStorage.removeItem(DB_TIMESTAMP_KEY);
            
            const request = indexedDB.open("SpotifyTracksDB", 1);
            
            request.onsuccess = function(event) {
                const db = event.target.result;
                const transaction = db.transaction(["database"], "readwrite");
                const objectStore = transaction.objectStore("database");
                const deleteRequest = objectStore.delete(DB_CACHE_KEY);
                
                deleteRequest.onsuccess = function() {
                    alert("Database cache cleared successfully. Reload the page to download again.");
                    location.reload();
                };
                
                deleteRequest.onerror = function() {
                    alert("Error clearing database cache.");
                };
            };
        }
        
        // Download and setup the database
        async function downloadAndSetupDB() {
            try {
                const downloadBtn = document.getElementById('download-db-btn');
                const progressContainer = document.getElementById('progress-container');
                
                downloadBtn.disabled = true;
                downloadBtn.innerText = "Downloading...";
                progressContainer.style.display = "block";
                
                // Start the download
                setProgressText("Downloading compressed database...");
                updateProgressBar(10);
                
                const response = await fetch('tracks.zip');
                
                if (!response.ok) {
                    throw new Error(`Failed to download database: ${response.status} ${response.statusText}`);
                }
                
                // Get content length if available
                const contentLength = response.headers.get('Content-Length');
                let receivedLength = 0;
                
                // Create a reader to read the response stream
                const reader = response.body.getReader();
                const chunks = [];
                
                setProgressText("Receiving data...");
                
                // Read the stream
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        break;
                    }
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // Update progress if content length is available
                    if (contentLength) {
                        const percentComplete = Math.round((receivedLength / parseInt(contentLength)) * 50) + 10;
                        updateProgressBar(percentComplete);
                        setProgressText(`Receiving data: ${Math.round(receivedLength / 1024 / 1024 * 10) / 10} MB`);
                    }
                }
                
                // Concatenate chunks
                updateProgressBar(60);
                setProgressText("Processing data...");
                
                const xzArrayBuffer = concatenateArrayBuffers(chunks);
                
                // Decompress the ZIP file
                updateProgressBar(70);
                setProgressText("Decompressing database...");
                
                const decompressedArrayBuffer = await decompressZip(xzArrayBuffer);
                
                // Initialize the database
                updateProgressBar(85);
                setProgressText("Initializing database...");
                
                // Store in cache
                updateProgressBar(90);
                setProgressText("Storing database in browser cache...");
                
                await storeDBInCache(decompressedArrayBuffer);
                
                // Initialize the database
                await initDatabaseFromArrayBuffer(decompressedArrayBuffer);
                
                // Complete!
                updateProgressBar(100);
                setProgressText("Database loaded successfully!");
                
                // Show the app
                setTimeout(() => {
                    showApp();
                }, 1000);
                
            } catch (error) {
                console.error("Error downloading database:", error);
                setProgressText(`Error: ${error.message}`);
                
                // Re-enable the download button
                const downloadBtn = document.getElementById('download-db-btn');
                downloadBtn.disabled = false;
                downloadBtn.innerText = "Try Again";
            }
        }
        
        // Decompress ZIP file
        async function decompressZip(arrayBuffer) {
            try {
                if (typeof JSZip === 'undefined') {
                    throw new Error("JSZip library not loaded. Please check your internet connection and try again.");
                }
                
                updateProgressBar(75);
                setProgressText("Unpacking database...");
                
                // Load the zip file
                const zip = new JSZip();
                const zipContents = await zip.loadAsync(arrayBuffer);
                
                // Find the tracks.db file in the zip
                let dbFile = null;
                
                // Look for tracks.db or any .db file
                for (const filename in zipContents.files) {
                    if (filename === 'tracks.db' || filename.endsWith('.db')) {
                        dbFile = zipContents.files[filename];
                        break;
                    }
                }
                
                if (!dbFile) {
                    throw new Error("Could not find database file in the ZIP archive.");
                }
                
                updateProgressBar(80);
                setProgressText(`Extracting ${dbFile.name}...`);
                
                // Extract the database file as an array buffer
                const dbArrayBuffer = await dbFile.async("arraybuffer", (metadata) => {
                    const progress = 80 + Math.round(metadata.percent * 5);
                    updateProgressBar(progress);
                    setProgressText(`Extracting: ${Math.round(metadata.percent)}%`);
                });
                
                return dbArrayBuffer;
            } catch (error) {
                console.error("Decompression error:", error);
                throw error;
            }
        }
        
        // Helper function to concatenate array buffers
        function concatenateArrayBuffers(arrays) {
            let totalLength = 0;
            for (const arr of arrays) {
                totalLength += arr.length;
            }
            
            const result = new Uint8Array(totalLength);
            let offset = 0;
            
            for (const arr of arrays) {
                result.set(arr, offset);
                offset += arr.length;
            }
            
            return result.buffer;
        }
        
        // Initialize the database from an array buffer
        async function initDatabaseFromArrayBuffer(arrayBuffer) {
            try {
                // Initialize SQL.js if not already initialized
                if (!state.SQL) {
                    state.SQL = await loadSqlJs({
                        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                    });
                }
                
                // Open the database
                const uInt8Array = new Uint8Array(arrayBuffer);
                state.db = new state.SQL.Database(uInt8Array);
                
                // Get list of all tables
                const result = state.db.exec(
                    "SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'tracks_%_%'"
                );
                
                if (result.length > 0 && result[0].values) {
                    // Extract table names
                    state.availableTables = result[0].values.map(row => row[0]);
                    
                    debugLog("Available tables:", state.availableTables);
                    
                    // Check what decades and languages are available
                    const availableDecades = new Set();
                    const availableLanguages = new Set();
                    
                    state.availableTables.forEach(table => {
                        // Extract decade and language from table name (format: tracks_DECADE_LANG)
                        const parts = table.split('_');
                        if (parts.length >= 3) {
                            const decade = parts[1];
                            const lang = parts[2];
                            availableDecades.add(decade);
                            availableLanguages.add(lang);
                        }
                    });
                    
                    debugLog("Available decades:", Array.from(availableDecades));
                    debugLog("Available languages:", Array.from(availableLanguages));
                    
                    // Disable decade buttons that don't have any tables
                    document.querySelectorAll('.decade-btn').forEach(btn => {
                        const decade = btn.getAttribute('data-decade');
                        if (!availableDecades.has(decade)) {
                            btn.disabled = true;
                            btn.title = "No tracks available for this decade";
                            btn.style.opacity = "0.5";
                        }
                    });
                    
                    // Disable language buttons that don't have any tables
                    document.querySelectorAll('.lang-btn').forEach(btn => {
                        const lang = btn.getAttribute('data-lang');
                        if (!availableLanguages.has(lang)) {
                            btn.disabled = true;
                            btn.title = "No tracks available in this language";
                            btn.style.opacity = "0.5";
                        }
                    });
                }
                
                return true;
            } catch (error) {
                console.error("Error initializing database:", error);
                setProgressText(`Error initializing database: ${error.message}`);
                throw error;
            }
        }
        
        // Setup event listeners for the main app
        function setupAppEventListeners() {
            // Set up event listeners for decade buttons
            const decadeBtns = document.querySelectorAll('.decade-btn');
            decadeBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    toggleDecade(this.getAttribute('data-decade'));
                });
            });
            
            // Set up event listeners for language buttons
            const langBtns = document.querySelectorAll('.lang-btn');
            langBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    toggleLanguage(this.getAttribute('data-lang'));
                });
            });
            
            // Select all decades
            document.getElementById('select-all-decades').addEventListener('click', function() {
                const allSelected = state.selectedDecades.length === decadeBtns.length;
                if (allSelected) {
                    // Deselect all
                    state.selectedDecades = [];
                    decadeBtns.forEach(btn => btn.classList.remove('selected'));
                } else {
                    // Select all
                    state.selectedDecades = Array.from(decadeBtns)
                        .filter(btn => !btn.disabled)
                        .map(btn => btn.getAttribute('data-decade'));
                    decadeBtns.forEach(btn => {
                        if (!btn.disabled) {
                            btn.classList.add('selected');
                        }
                    });
                }
                updateSelectionDisplay();
            });
            
            // Select all languages
            document.getElementById('select-all-languages').addEventListener('click', function() {
                const allSelected = state.selectedLanguages.length === langBtns.length;
                if (allSelected) {
                    // Deselect all
                    state.selectedLanguages = [];
                    langBtns.forEach(btn => btn.classList.remove('selected'));
                } else {
                    // Select all
                    state.selectedLanguages = Array.from(langBtns)
                        .filter(btn => !btn.disabled)
                        .map(btn => btn.getAttribute('data-lang'));
                    langBtns.forEach(btn => {
                        if (!btn.disabled) {
                            btn.classList.add('selected');
                        }
                    });
                }
                updateSelectionDisplay();
            });
            
            // Find track button
            document.getElementById('find-track-btn').addEventListener('click', findRandomTrack);
        }
        
        // Load SQL.js promise
        const loadSqlJs = function(config) {
            return new Promise((resolve, reject) => {
                if (window.initSqlJs) {
                    window.initSqlJs(config).then(resolve).catch(reject);
                } else {
                    document.querySelector('script[src*="sql-wasm.js"]').addEventListener('load', function() {
                        window.initSqlJs(config).then(resolve).catch(reject);
                    });
                }
            });
        };
        
                    // Show the main app
        function showApp() {
            document.getElementById('db-setup').style.display = 'none';
            document.getElementById('app-container').style.display = 'block';
            document.getElementById('footer-text').innerHTML = 'Select at least one decade and language to find a random track';
        }
        
        // Function to toggle decade selection
        function toggleDecade(decade) {
            const index = state.selectedDecades.indexOf(decade);
            const btn = document.querySelector(`.decade-btn[data-decade="${decade}"]`);
            
            if (index === -1) {
                // Add to selection
                state.selectedDecades.push(decade);
                btn.classList.add('selected');
            } else {
                // Remove from selection
                state.selectedDecades.splice(index, 1);
                btn.classList.remove('selected');
            }
            
            updateSelectionDisplay();
        }
        
        // Function to toggle language selection
        function toggleLanguage(lang) {
            const index = state.selectedLanguages.indexOf(lang);
            const btn = document.querySelector(`.lang-btn[data-lang="${lang}"]`);
            
            if (index === -1) {
                // Add to selection
                state.selectedLanguages.push(lang);
                btn.classList.add('selected');
            } else {
                // Remove from selection
                state.selectedLanguages.splice(index, 1);
                btn.classList.remove('selected');
            }
            
            updateSelectionDisplay();
        }
        
        // Update the selection display
        function updateSelectionDisplay() {
            const selectionDisplay = document.getElementById('selection-display');
            selectionDisplay.innerHTML = '';
            
            if (state.selectedDecades.length === 0 && state.selectedLanguages.length === 0) {
                selectionDisplay.innerHTML = '<div class="selection-tag">No selection yet</div>';
                return;
            }
            
            // Add decades
            if (state.selectedDecades.length > 0) {
                if (state.selectedDecades.length === document.querySelectorAll('.decade-btn:not([disabled])').length) {
                    selectionDisplay.innerHTML += '<div class="selection-tag">All Decades</div>';
                } else {
                    state.selectedDecades.forEach(decade => {
                        selectionDisplay.innerHTML += `<div class="selection-tag">${decade}s</div>`;
                    });
                }
            } else {
                selectionDisplay.innerHTML += '<div class="selection-tag">No decades selected</div>';
            }
            
            // Add languages
            if (state.selectedLanguages.length > 0) {
                if (state.selectedLanguages.length === document.querySelectorAll('.lang-btn:not([disabled])').length) {
                    selectionDisplay.innerHTML += '<div class="selection-tag">All Languages</div>';
                } else {
                    state.selectedLanguages.forEach(lang => {
                        const langBtn = document.querySelector(`.lang-btn[data-lang="${lang}"]`);
                        const langName = langBtn.textContent.trim();
                        selectionDisplay.innerHTML += `<div class="selection-tag">${langName}</div>`;
                    });
                }
            } else {
                selectionDisplay.innerHTML += '<div class="selection-tag">No languages selected</div>';
            }
        }
        
        // Find a random track based on selections
        async function findRandomTrack() {
            if (state.isLoading) return;
            
            // Validate selections
            if (state.selectedDecades.length === 0 || state.selectedLanguages.length === 0) {
                setMessage("Please select at least one decade and one language!");
                return;
            }
            
            try {
                // Set loading state
                state.isLoading = true;
                document.getElementById('loader').style.display = 'block';
                setMessage("Finding your random track...");
                
                // Build a UNION query for all selected decade/language combinations
                const validTableNames = [];
                
                // Check which combinations exist in the database
                for (const decade of state.selectedDecades) {
                    for (const lang of state.selectedLanguages) {
                        const tableName = `tracks_${decade}_${lang}`;
                        if (state.availableTables.includes(tableName)) {
                            validTableNames.push(tableName);
                        }
                    }
                }
                
                debugLog("Valid tables for query:", validTableNames);
                
                if (validTableNames.length === 0) {
                    setMessage("No tracks found for your selection. Please try different options.");
                    document.getElementById('loader').style.display = 'none';
                    state.isLoading = false;
                    return;
                }
                
                // Build the UNION query
                const unionQuery = validTableNames
                    .map(table => `SELECT uri FROM ${table}`)
                    .join(" UNION ");
                
                const finalQuery = `SELECT uri FROM (${unionQuery}) ORDER BY RANDOM() LIMIT 1`;
                debugLog("Final query:", finalQuery);
                
                // Execute the query
                const result = state.db.exec(finalQuery);
                
                if (result.length > 0 && result[0].values && result[0].values.length > 0) {
                    const uri = result[0].values[0][0];
                    debugLog("Found URI:", uri);
                    redirectToSpotify(uri);
                } else {
                    setMessage("No tracks found for your selection. Please try different options.");
                }
                
            } catch (error) {
                console.error("Error finding random track:", error);
                setMessage(`Error: ${error.message}`);
            } finally {
                state.isLoading = false;
                document.getElementById('loader').style.display = 'none';
            }
        }
        
        // Function to redirect to Spotify
        function redirectToSpotify(uri) {
            // Extract just the ID part of the URI
            const trackId = uri.split(':').pop();
            
            // Check if user is on mobile
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            setMessage(`Track found! Redirecting to Spotify...`);
            
            if (isMobile) {
                // Try to open Spotify app first
                window.location.href = `spotify:track:${trackId}`;
                
                // Fallback to web version after a short delay if app doesn't open
                setTimeout(function() {
                    window.location.href = `https://open.spotify.com/track/${trackId}`;
                }, 1500);
            } else {
                // On desktop, just use the web player
                window.location.href = `https://open.spotify.com/track/${trackId}`;
            }
        }
        
        // Helper function to set progress text
        function setProgressText(text) {
            document.getElementById('progress-text').innerText = text;
        }
        
        // Helper function to update progress bar
        function updateProgressBar(percent) {
            document.getElementById('progress-bar').style.width = `${percent}%`;
        }
        
        // Helper function to set message
        function setMessage(text) {
            document.getElementById('message').innerText = text;
        }
        
        // Helper function for debug logging
        function debugLog(...args) {
            if (state.debugMode) {
                console.log(...args);
                const debugOutput = document.getElementById('debug-output');
                debugOutput.textContent += args.map(arg => 
                    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
                ).join(' ') + '\n';
                
                // Auto-scroll to bottom
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
        }
    </script>
</body>
</html>
